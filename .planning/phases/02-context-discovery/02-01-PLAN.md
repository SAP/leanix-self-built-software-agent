---
phase: 02-context-discovery
plan: 01
type: execute
---

<objective>
Create the context loading infrastructure for discovering and loading user-provided context files.

Purpose: Establish the core file discovery and loading logic that reads context from local org config and repository files.
Output: New `context_loader.py` service module and `load_context_runnable.py` for workflow integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/dto/context_dto.py
@src/dto/state_dto.py
@src/nodes/runnables/clone_repo_runnable.py

**Constraining decisions from STATE.md:**
- Context files stored locally at `~/.sbs-discovery/{org}.md` for org-level
- Repo context at `.sbs-discovery.md` in repository root
- Inheritance: repo context extends/overrides org context

**Established patterns (from codebase):**
- Services in `src/services/` with function-based modules
- Runnables in `src/nodes/runnables/` following `{name}_runnable.py` pattern
- Use `pathlib.Path` for file operations with `.read_text(encoding="utf-8")`
- structlog for logging via `get_logger(__name__)`
- Type hints on all parameters and returns
- Google-style docstrings

**From Phase 1:**
- `DiscoveryContext` dataclass available in `src/dto/context_dto.py`
- `merge_contexts()` function handles org + repo combination
- `RootRepoState.discovery_context` field ready for population
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create context loader service module</name>
  <files>src/services/context_loader.py</files>
  <action>
Create new file `src/services/context_loader.py` with:

1. Imports: `from __future__ import annotations`, `pathlib.Path`, `typing.Optional`, `os`, structlog logger

2. Constants:
   - `ORG_CONTEXT_DIR = Path.home() / ".sbs-discovery"` - base directory for org configs
   - `REPO_CONTEXT_FILENAME = ".sbs-discovery.md"` - filename to look for in repos

3. Function `load_org_context(org_name: str) -> tuple[Optional[str], Optional[str]]`:
   - Build path: `ORG_CONTEXT_DIR / f"{org_name}.md"`
   - If file exists and is readable, return `(content, str(path))`
   - If not exists, log debug message and return `(None, None)`
   - Handle exceptions gracefully (log warning, return None)

4. Function `load_repo_context(local_path: str) -> tuple[Optional[str], Optional[str]]`:
   - Build path: `Path(local_path) / REPO_CONTEXT_FILENAME`
   - If file exists and is readable, return `(content, str(path))`
   - If not exists, return `(None, None)` (this is expected/normal)
   - Handle exceptions gracefully (log warning, return None)

5. Function `build_discovery_context(org_name: Optional[str], local_path: Optional[str], org_context_override: Optional[str] = None, repo_context_override: Optional[str] = None) -> DiscoveryContext`:
   - If `org_context_override` provided, use it (CLI override); else call `load_org_context(org_name)` if org_name given
   - If `repo_context_override` provided, use it (CLI override); else call `load_repo_context(local_path)` if local_path given
   - Call `merge_contexts(org_content, repo_content)` to get merged result
   - Return `DiscoveryContext` with all fields populated
   - Log info about what context was loaded (for debugging)

Use defensive coding - never crash on missing/unreadable files, just return None and log.
  </action>
  <verify>uv run python -c "from src.services.context_loader import load_org_context, load_repo_context, build_discovery_context; print('All imports OK')"</verify>
  <done>Context loader module exists with all three functions, imports without error, handles missing files gracefully</done>
</task>

<task type="auto">
  <name>Task 2: Create context loading runnable</name>
  <files>src/nodes/runnables/load_context_runnable.py</files>
  <action>
Create new file `src/nodes/runnables/load_context_runnable.py` with:

1. Imports: `from __future__ import annotations`, state DTOs, context loader service, logger

2. Function `load_context_runnable(state: RootRepoState) -> RootRepoState`:
   - Docstring explaining this loads repo context from cloned repository
   - Extract org name from `state.repo_root_url` (parse URL to get org/owner)
   - Call `build_discovery_context(org_name, state.local_path)`
   - Attach result to `state.discovery_context`
   - Log what was found (org context loaded: yes/no, repo context loaded: yes/no)
   - Return updated state

3. Helper function `_extract_org_from_url(repo_url: str) -> Optional[str]`:
   - Parse GitHub URL to extract organization/owner name
   - Handle both `https://github.com/org/repo` and `https://github.com/org/repo.git`
   - Return None if URL doesn't match expected pattern

Follow existing runnable patterns from `clone_repo_runnable.py`:
- Function takes state, returns updated state
- Uses structlog logger
- Handles exceptions with logging

Note: This runnable will be called AFTER clone_repo_runnable, so `state.local_path` will be populated.
  </action>
  <verify>uv run python -c "from src.nodes.runnables.load_context_runnable import load_context_runnable; print('Runnable imports OK')"</verify>
  <done>Context loading runnable exists, imports without error, follows established runnable pattern</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `uv run python -c "from src.services.context_loader import load_org_context, load_repo_context, build_discovery_context"` succeeds
- [ ] `uv run python -c "from src.nodes.runnables.load_context_runnable import load_context_runnable"` succeeds
- [ ] `load_org_context("nonexistent")` returns `(None, None)` without crashing
- [ ] `load_repo_context("/nonexistent/path")` returns `(None, None)` without crashing
- [ ] `build_discovery_context(None, None)` returns empty `DiscoveryContext` without crashing
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No import errors introduced
- Context loader handles all edge cases gracefully (missing files, unreadable files, None inputs)
- Runnable ready for workflow integration in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/02-context-discovery/02-01-SUMMARY.md`:

# Phase 2 Plan 1: Context Loading Infrastructure Summary

**[One-liner describing what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `src/services/context_loader.py` - New context discovery and loading service
- `src/nodes/runnables/load_context_runnable.py` - New runnable for workflow integration

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 02-02-PLAN.md (Workflow & CLI Integration)
</output>
